// DO NOT EDIT, generated by goctl
package handler

import (
	"net/http"
	"os"
	"strings"

	"github.com/tal-tech/go-zero/core/logx"

	"file/internal/svc"

	"github.com/tal-tech/go-zero/rest"
)

func filehandler(filepath string) http.HandlerFunc {
	return func(w http.ResponseWriter, req *http.Request) {
		http.ServeFile(w, req, filepath)
	}
}
func dirhandler(patern, filedir string) http.HandlerFunc {

	return func(w http.ResponseWriter, req *http.Request) {
		handler := http.StripPrefix(patern, http.FileServer(http.Dir(filedir)))
		handler.ServeHTTP(w, req)
	}
}

//静态资源文件服务
func RegisterFileHandlers(engine *rest.Server, serverCtx *svc.ServiceContext) {
	//启用静态资源服务
	//serverCtx.Info(serverCtx.Config.FileServe)
	//fileserver是一个数组[patern1=dir1,patern2=dir2]
	for _, filepatern := range serverCtx.Config.FileServe {
		patern := strings.Split(filepatern, "=")
		if len(patern) < 2 {
			continue
		}
		if len(patern[1]) == 0 {
			patern[1] = "./"
		}
		f, e := os.Stat(patern[1])
		if e != nil {
			logx.Error("RegisterStaticFs error %s", e.Error())
			continue
		}
		if f.IsDir() {
			//通过格式来匹配
			dirlevel := []string{":1", ":2", ":3", ":4", ":5", ":6", ":7", ":8"}
			for i := 1; i < len(dirlevel); i++ {
				path := patern[0] + strings.Join(dirlevel[:i], "/")
				engine.AddRoute(
					rest.Route{
						Method:  http.MethodGet,
						Path:    path,
						Handler: dirhandler(patern[0], patern[1]),
					})
				logx.Infof("register dir  %s  %s", path, patern[1])
			}
		} else {
			logx.Infof("register file  %s  %s", patern[0], patern[1])
			engine.AddRoute(
				rest.Route{
					Method:  http.MethodGet,
					Path:    patern[0],
					Handler: filehandler(patern[1]),
				})
		}

	}
}
